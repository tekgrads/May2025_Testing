**JAVA8:

*Java 8 introduced significant improvements to the language and libraries, bringing in a more functional programming style.	

**Types of programming languages: 

*Procedural programming Language
*Object Oriented programming Language
*Scripting Language

*JAVA 8 CORE FEATURES:

*Lambda Expressions
*Functional Interfaces
*Default methods
*Predicates
*Functions
*Double colon operator(::)
*Stream API
*Date and Time API


**LAMBDA EXPRESSION:

*LISP is the first programming which uses Lambda Expression.
*Lambda helps in enabling functional programming in java.
*Lambda Expression is just an anonymous(nameless function). It doesn't have the name , return type and access modifiers.
*It is also known as anonymous functions or closures.
*A function without having name is called lambda expression.


*Example1:

public void m1() {                                     
	sop("hello");                     -->      {

}                                                   sop("hello")
                                                   }


Example2:

public void add(inta, intb){                       
	sop(a+b);                         -->    (int a, int b)-->sop(a+b);
}


**If the type of the parameter can be decided by compiler automatically based on the context then we can remove types also.
*The above Lambda expression we can rewrite as (a,b)-->sop(a+b);


Example3:

public String str(String str){                   -->  (String str)--> return str;
return str;                                            (str)-->str;
}

**Conclusions:

*A lambda expression can have zero or more number of parameters(arguments).
()-->sop("hello");
(int a)-->sop(a);
(int a, int b)-->return a+b;

*The data type can also be removed if the compiler expects the type based on the context
(int a, int b)-->sop(a+b);
(a,b)-->sop(a+b);

**If multiple parameters present then these parameters should be separated by comma(,).

**If no parameter is available then we have to use empty parameter like().
()--> sop("hello");

**If only one parameter is available and if the compile can expect the type then we can remove the type 
(int a)-->sop(a);
(a)-->sop(a);

A -->sop(a)l

**Use{} if the method body has multiple parameters.

**Once we write lambda expression we can call that expression just like a method, for this functional interfaces are required.  


**Advantages of Lambda expression:

*we can reduce length of the code so that readability of the code will be improved.
*We can solve complexity of anonymous inner classes.
*We can provide lambda expression in the place of object.
*We can pass lambda expression as arguments to methods.


**FUNCTIONAL INTERFACE:

**If an interface contain only one abstract method, such type of interfaces are called functional interfaces and the method is called functional method or single abstract method(SAM).

Example:

**Runnable-->It contains only run() method
**Comparable-->It contains only compareTo() method
**ActionListener-->It contains only actionPerformed()
**Callable-->It contains only call() method

**Inside functional interface in addition to single Abstract method(SAM) we write any number of default and static methods.

** Example1:

interface Interf 
	public abstract void m1();
	default void m2(){
		System.out.println("hello")'
}
}


Example2:
@Functional Interface
interface Interf{
    public void m1():
} 


**Inside functional Interface only one abstract method is present, if it is more than one method then compiler raise an error message that is called we will get an compilation error.

Example3:
@Functional Interface
interface Interf{
	public void m1();
	public void m2();
}
*This code gives compilation error.

Example4:
@Functional Interface 
interface Interf{ 
}


*This code gives an compilation error because no method is present.


Example5:

@Functional Interface
interface A{
	public void methodOne();
} 
@Functional Interface
interface B extends A{
}

*In the child interface we can define exactly same parent interface abstract method.

Example6:

@Functional Interface
interface A{
	public void methodOne();
}
@Functional Interface
interface B extends A{
	public void methodOne();
}

*In the child interface we can't define any new abstract methods otherwise child interface won't be Functional Interface and if we are trying to use@Functional Intreface annotation then compiler give an error message.

Example7:

@Functional Interface
interface A{
	public void methodOne();
}
@Functional Interface 
interface B extends A{
	public void methodTwo();
}

*It gives compilation error because there are two abstract methods in functional Interface.

Example8:

@Functional Interface 
interface A {                       } No compile time error
	public void methodOne();
 }
interface B extends A {
	public void methodTwo();    } This's normal interface so that code compiles without error
}

**Type inference feature it is trying to guess the datatype of lambda expressions.

**Lambda expression is going to provide the implementation of SAM(single abstract method).




Example1: (using Functional Interface)

 package com.tekgrads;


interface Interf {
	public void m1();		
}

class InterfImp1 implements Interf {
	@Override
	public void m1() {
		System.out.println("Inside m1 of InterfImp1");
		
	}
}

public class Example1 {
	
	public static void main(String[] args) {
		Interf i = new InterfImp1 ();
		i.m1();
	}
}

OUTPUT:
Inside m1 of InterfImp1


Example2:


package com.tekgrads;


interface Interf2 {
	public void m1();	
}

abstract class Test {
	public abstract void m1();	
}

class Test2 {
	public void m1() {
		System.out.println("In Test2 m1");
	}
}

class TestImple extends Test {

	@Override
	public void m1() {
		System.out.println("In Concrete m1 method");
		
	}
	
}


public class Example2 {

	public static void main(String[] args) {
		
		Interf2 i = new Interf2() {
			
			@Override
			public void m1() {
				System.out.println("Inside m1 of InterfImpl2");
				
			}
		};
		
		
		i.m1();
		
		
		Test t = new TestImple();
		t.m1();
		
		Test t2  = new Test() {
			
			@Override
			public void m1() {
				System.out.println("Another Impl of m1 in annonymous inner class");
				
			}
		};
		
		t2.m1();
		
		Test2 t3 = new Test2() {
			@Override
			public void m1() {
				System.out.println("In Anonymous m1 method");
				
			}
		};
		
		t3.m1();
	}

}
OUTPUT:

Inside m1 of InterfImpl2
In Concrete m1 method
Another Impl of m1 in annonymous inner class
In Anonymous m1 method


Example3:(By using lambda expression)

package com.tekgrads;


interface Interf3 {
	public void m1();		
}

public class Example3 {
	
	public static void main(String[] args) {
		
		Interf3 i = ()->System.out.println("in lambda expression m1 method");
		
		i.m1();
	}
}

OUTPUT:
in lambda expression m1 method


Example4: 
package com.tekgrads;

interface Interf4 {
	public void m1();
}

class Test3 {
	int x = 888;

	public void m2() {
		Interf4 i = new Interf4() {

			int x = 999;

			@Override
			public void m1() {
				System.out.println(this.x);

			}
		};
		i.m1();
	}
}

class Test4 {
	int x = 888;

	public void m2() {
		int y= 20;
		
		Interf4 i2 = () -> {
			int x = 999;
			//y=200;
			System.out.println(this.x);
			System.out.println(y);
		};
		i2.m1();
	}
}

public class Example4 {

	public static void main(String[] args) {

		Test3 t3 = new Test3();

		t3.m2();

		Test4 t4 = new Test4();

		t4.m2();

	}

}

OUTPUT:
999
888
20





**Note:
*Anonymous inner class can extend concrete class, can extend abstract class, can implement interface with any number of methods but
*Lambda expression can implement an interface with only single abstract method(Functional Interface).
*Hence if anonymous inner class implements Functional Interface in that particular case only we can replace with lambda expressions. Hence wherever anonymous inner class concept is there, it may not possible to replace with lambda expressions.
*Anonymous inner class! = Lambda Expression
*Inside anonymous inner class we can declare instance variables.
*Inside anonymous inner class "this" always refers current inner class object(anonymous inner class) but not related outer class object.
 
**Inside lambda expression we can't declare instance variables.
*Whatever the variables declare inside lambda expression are simply acts as local variables.
*Within lambda expression "this" keyword represents current outer class object reference(that is current enclosing class reference in which we declare lambda expression).

































 










































                                                                         